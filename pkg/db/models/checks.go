// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Check is an object representing the database table.
type Check struct {
	Canary       null.JSON   `boil:"canary" json:"canary,omitempty" toml:"canary" yaml:"canary,omitempty"`
	CanaryName   null.String `boil:"canary_name" json:"canary_name,omitempty" toml:"canary_name" yaml:"canary_name,omitempty"`
	CheckType    string      `boil:"check_type" json:"check_type" toml:"check_type" yaml:"check_type"`
	Description  null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	DisplayType  null.String `boil:"display_type" json:"display_type,omitempty" toml:"display_type" yaml:"display_type,omitempty"`
	Endpoint     null.String `boil:"endpoint" json:"endpoint,omitempty" toml:"endpoint" yaml:"endpoint,omitempty"`
	Icon         null.String `boil:"icon" json:"icon,omitempty" toml:"icon" yaml:"icon,omitempty"`
	ID           string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Interval     null.Int    `boil:"interval" json:"interval,omitempty" toml:"interval" yaml:"interval,omitempty"`
	Key          string      `boil:"key" json:"key" toml:"key" yaml:"key"`
	Labels       null.JSON   `boil:"labels" json:"labels,omitempty" toml:"labels" yaml:"labels,omitempty"`
	Name         string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Namespace    string      `boil:"namespace" json:"namespace" toml:"namespace" yaml:"namespace"`
	Owner        null.String `boil:"owner" json:"owner,omitempty" toml:"owner" yaml:"owner,omitempty"`
	RunnerLabels null.JSON   `boil:"runner_labels" json:"runner_labels,omitempty" toml:"runner_labels" yaml:"runner_labels,omitempty"`
	RunnerName   null.String `boil:"runner_name" json:"runner_name,omitempty" toml:"runner_name" yaml:"runner_name,omitempty"`
	Schedule     null.String `boil:"schedule" json:"schedule,omitempty" toml:"schedule" yaml:"schedule,omitempty"`
	Severity     null.String `boil:"severity" json:"severity,omitempty" toml:"severity" yaml:"severity,omitempty"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *checkR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L checkL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CheckColumns = struct {
	Canary       string
	CanaryName   string
	CheckType    string
	Description  string
	DisplayType  string
	Endpoint     string
	Icon         string
	ID           string
	Interval     string
	Key          string
	Labels       string
	Name         string
	Namespace    string
	Owner        string
	RunnerLabels string
	RunnerName   string
	Schedule     string
	Severity     string
	UpdatedAt    string
}{
	Canary:       "canary",
	CanaryName:   "canary_name",
	CheckType:    "check_type",
	Description:  "description",
	DisplayType:  "display_type",
	Endpoint:     "endpoint",
	Icon:         "icon",
	ID:           "id",
	Interval:     "interval",
	Key:          "key",
	Labels:       "labels",
	Name:         "name",
	Namespace:    "namespace",
	Owner:        "owner",
	RunnerLabels: "runner_labels",
	RunnerName:   "runner_name",
	Schedule:     "schedule",
	Severity:     "severity",
	UpdatedAt:    "updated_at",
}

var CheckTableColumns = struct {
	Canary       string
	CanaryName   string
	CheckType    string
	Description  string
	DisplayType  string
	Endpoint     string
	Icon         string
	ID           string
	Interval     string
	Key          string
	Labels       string
	Name         string
	Namespace    string
	Owner        string
	RunnerLabels string
	RunnerName   string
	Schedule     string
	Severity     string
	UpdatedAt    string
}{
	Canary:       "checks.canary",
	CanaryName:   "checks.canary_name",
	CheckType:    "checks.check_type",
	Description:  "checks.description",
	DisplayType:  "checks.display_type",
	Endpoint:     "checks.endpoint",
	Icon:         "checks.icon",
	ID:           "checks.id",
	Interval:     "checks.interval",
	Key:          "checks.key",
	Labels:       "checks.labels",
	Name:         "checks.name",
	Namespace:    "checks.namespace",
	Owner:        "checks.owner",
	RunnerLabels: "checks.runner_labels",
	RunnerName:   "checks.runner_name",
	Schedule:     "checks.schedule",
	Severity:     "checks.severity",
	UpdatedAt:    "checks.updated_at",
}

// Generated where

var CheckWhere = struct {
	Canary       whereHelpernull_JSON
	CanaryName   whereHelpernull_String
	CheckType    whereHelperstring
	Description  whereHelpernull_String
	DisplayType  whereHelpernull_String
	Endpoint     whereHelpernull_String
	Icon         whereHelpernull_String
	ID           whereHelperstring
	Interval     whereHelpernull_Int
	Key          whereHelperstring
	Labels       whereHelpernull_JSON
	Name         whereHelperstring
	Namespace    whereHelperstring
	Owner        whereHelpernull_String
	RunnerLabels whereHelpernull_JSON
	RunnerName   whereHelpernull_String
	Schedule     whereHelpernull_String
	Severity     whereHelpernull_String
	UpdatedAt    whereHelpertime_Time
}{
	Canary:       whereHelpernull_JSON{field: "\"checks\".\"canary\""},
	CanaryName:   whereHelpernull_String{field: "\"checks\".\"canary_name\""},
	CheckType:    whereHelperstring{field: "\"checks\".\"check_type\""},
	Description:  whereHelpernull_String{field: "\"checks\".\"description\""},
	DisplayType:  whereHelpernull_String{field: "\"checks\".\"display_type\""},
	Endpoint:     whereHelpernull_String{field: "\"checks\".\"endpoint\""},
	Icon:         whereHelpernull_String{field: "\"checks\".\"icon\""},
	ID:           whereHelperstring{field: "\"checks\".\"id\""},
	Interval:     whereHelpernull_Int{field: "\"checks\".\"interval\""},
	Key:          whereHelperstring{field: "\"checks\".\"key\""},
	Labels:       whereHelpernull_JSON{field: "\"checks\".\"labels\""},
	Name:         whereHelperstring{field: "\"checks\".\"name\""},
	Namespace:    whereHelperstring{field: "\"checks\".\"namespace\""},
	Owner:        whereHelpernull_String{field: "\"checks\".\"owner\""},
	RunnerLabels: whereHelpernull_JSON{field: "\"checks\".\"runner_labels\""},
	RunnerName:   whereHelpernull_String{field: "\"checks\".\"runner_name\""},
	Schedule:     whereHelpernull_String{field: "\"checks\".\"schedule\""},
	Severity:     whereHelpernull_String{field: "\"checks\".\"severity\""},
	UpdatedAt:    whereHelpertime_Time{field: "\"checks\".\"updated_at\""},
}

// CheckRels is where relationship names are stored.
var CheckRels = struct {
}{}

// checkR is where relationships are stored.
type checkR struct {
}

// NewStruct creates a new relationship struct
func (*checkR) NewStruct() *checkR {
	return &checkR{}
}

// checkL is where Load methods for each relationship are stored.
type checkL struct{}

var (
	checkAllColumns            = []string{"canary", "canary_name", "check_type", "description", "display_type", "endpoint", "icon", "id", "interval", "key", "labels", "name", "namespace", "owner", "runner_labels", "runner_name", "schedule", "severity", "updated_at"}
	checkColumnsWithoutDefault = []string{"canary", "canary_name", "check_type", "description", "display_type", "endpoint", "icon", "id", "interval", "key", "labels", "name", "namespace", "owner", "runner_labels", "runner_name", "schedule", "severity", "updated_at"}
	checkColumnsWithDefault    = []string{}
	checkPrimaryKeyColumns     = []string{"key"}
)

type (
	// CheckSlice is an alias for a slice of pointers to Check.
	// This should almost always be used instead of []Check.
	CheckSlice []*Check
	// CheckHook is the signature for custom Check hook methods
	CheckHook func(boil.Executor, *Check) error

	checkQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	checkType                 = reflect.TypeOf(&Check{})
	checkMapping              = queries.MakeStructMapping(checkType)
	checkPrimaryKeyMapping, _ = queries.BindMapping(checkType, checkMapping, checkPrimaryKeyColumns)
	checkInsertCacheMut       sync.RWMutex
	checkInsertCache          = make(map[string]insertCache)
	checkUpdateCacheMut       sync.RWMutex
	checkUpdateCache          = make(map[string]updateCache)
	checkUpsertCacheMut       sync.RWMutex
	checkUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var checkBeforeInsertHooks []CheckHook
var checkBeforeUpdateHooks []CheckHook
var checkBeforeDeleteHooks []CheckHook
var checkBeforeUpsertHooks []CheckHook

var checkAfterInsertHooks []CheckHook
var checkAfterSelectHooks []CheckHook
var checkAfterUpdateHooks []CheckHook
var checkAfterDeleteHooks []CheckHook
var checkAfterUpsertHooks []CheckHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Check) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range checkBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Check) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range checkBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Check) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range checkBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Check) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range checkBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Check) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range checkAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Check) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range checkAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Check) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range checkAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Check) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range checkAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Check) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range checkAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCheckHook registers your hook function for all future operations.
func AddCheckHook(hookPoint boil.HookPoint, checkHook CheckHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		checkBeforeInsertHooks = append(checkBeforeInsertHooks, checkHook)
	case boil.BeforeUpdateHook:
		checkBeforeUpdateHooks = append(checkBeforeUpdateHooks, checkHook)
	case boil.BeforeDeleteHook:
		checkBeforeDeleteHooks = append(checkBeforeDeleteHooks, checkHook)
	case boil.BeforeUpsertHook:
		checkBeforeUpsertHooks = append(checkBeforeUpsertHooks, checkHook)
	case boil.AfterInsertHook:
		checkAfterInsertHooks = append(checkAfterInsertHooks, checkHook)
	case boil.AfterSelectHook:
		checkAfterSelectHooks = append(checkAfterSelectHooks, checkHook)
	case boil.AfterUpdateHook:
		checkAfterUpdateHooks = append(checkAfterUpdateHooks, checkHook)
	case boil.AfterDeleteHook:
		checkAfterDeleteHooks = append(checkAfterDeleteHooks, checkHook)
	case boil.AfterUpsertHook:
		checkAfterUpsertHooks = append(checkAfterUpsertHooks, checkHook)
	}
}

// OneG returns a single check record from the query using the global executor.
func (q checkQuery) OneG() (*Check, error) {
	return q.One(boil.GetDB())
}

// One returns a single check record from the query.
func (q checkQuery) One(exec boil.Executor) (*Check, error) {
	o := &Check{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for checks")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Check records from the query using the global executor.
func (q checkQuery) AllG() (CheckSlice, error) {
	return q.All(boil.GetDB())
}

// All returns all Check records from the query.
func (q checkQuery) All(exec boil.Executor) (CheckSlice, error) {
	var o []*Check

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Check slice")
	}

	if len(checkAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Check records in the query, and panics on error.
func (q checkQuery) CountG() (int64, error) {
	return q.Count(boil.GetDB())
}

// Count returns the count of all Check records in the query.
func (q checkQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count checks rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q checkQuery) ExistsG() (bool, error) {
	return q.Exists(boil.GetDB())
}

// Exists checks if the row exists in the table.
func (q checkQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if checks exists")
	}

	return count > 0, nil
}

// Checks retrieves all the records using an executor.
func Checks(mods ...qm.QueryMod) checkQuery {
	mods = append(mods, qm.From("\"checks\""))
	return checkQuery{NewQuery(mods...)}
}

// FindCheckG retrieves a single record by ID.
func FindCheckG(key string, selectCols ...string) (*Check, error) {
	return FindCheck(boil.GetDB(), key, selectCols...)
}

// FindCheck retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCheck(exec boil.Executor, key string, selectCols ...string) (*Check, error) {
	checkObj := &Check{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"checks\" where \"key\"=$1", sel,
	)

	q := queries.Raw(query, key)

	err := q.Bind(nil, exec, checkObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from checks")
	}

	if err = checkObj.doAfterSelectHooks(exec); err != nil {
		return checkObj, err
	}

	return checkObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Check) InsertG(columns boil.Columns) error {
	return o.Insert(boil.GetDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Check) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no checks provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(checkColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	checkInsertCacheMut.RLock()
	cache, cached := checkInsertCache[key]
	checkInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			checkAllColumns,
			checkColumnsWithDefault,
			checkColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(checkType, checkMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(checkType, checkMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"checks\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"checks\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into checks")
	}

	if !cached {
		checkInsertCacheMut.Lock()
		checkInsertCache[key] = cache
		checkInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// UpdateG a single Check record using the global executor.
// See Update for more documentation.
func (o *Check) UpdateG(columns boil.Columns) (int64, error) {
	return o.Update(boil.GetDB(), columns)
}

// Update uses an executor to update the Check.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Check) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	checkUpdateCacheMut.RLock()
	cache, cached := checkUpdateCache[key]
	checkUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			checkAllColumns,
			checkPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update checks, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"checks\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, checkPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(checkType, checkMapping, append(wl, checkPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update checks row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for checks")
	}

	if !cached {
		checkUpdateCacheMut.Lock()
		checkUpdateCache[key] = cache
		checkUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q checkQuery) UpdateAllG(cols M) (int64, error) {
	return q.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q checkQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for checks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for checks")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o CheckSlice) UpdateAllG(cols M) (int64, error) {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CheckSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), checkPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"checks\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, checkPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in check slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all check")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Check) UpsertG(updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(boil.GetDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Check) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no checks provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(checkColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	checkUpsertCacheMut.RLock()
	cache, cached := checkUpsertCache[key]
	checkUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			checkAllColumns,
			checkColumnsWithDefault,
			checkColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			checkAllColumns,
			checkPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert checks, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(checkPrimaryKeyColumns))
			copy(conflict, checkPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"checks\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(checkType, checkMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(checkType, checkMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert checks")
	}

	if !cached {
		checkUpsertCacheMut.Lock()
		checkUpsertCache[key] = cache
		checkUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// DeleteG deletes a single Check record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Check) DeleteG() (int64, error) {
	return o.Delete(boil.GetDB())
}

// Delete deletes a single Check record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Check) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Check provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), checkPrimaryKeyMapping)
	sql := "DELETE FROM \"checks\" WHERE \"key\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from checks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for checks")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q checkQuery) DeleteAllG() (int64, error) {
	return q.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all matching rows.
func (q checkQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no checkQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from checks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for checks")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o CheckSlice) DeleteAllG() (int64, error) {
	return o.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CheckSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(checkBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), checkPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"checks\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, checkPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from check slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for checks")
	}

	if len(checkAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Check) ReloadG() error {
	if o == nil {
		return errors.New("models: no Check provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Check) Reload(exec boil.Executor) error {
	ret, err := FindCheck(exec, o.Key)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CheckSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("models: empty CheckSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CheckSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CheckSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), checkPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"checks\".* FROM \"checks\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, checkPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CheckSlice")
	}

	*o = slice

	return nil
}

// CheckExistsG checks if the Check row exists.
func CheckExistsG(key string) (bool, error) {
	return CheckExists(boil.GetDB(), key)
}

// CheckExists checks if the Check row exists.
func CheckExists(exec boil.Executor, key string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"checks\" where \"key\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, key)
	}
	row := exec.QueryRow(sql, key)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if checks exists")
	}

	return exists, nil
}
