// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Component is an object representing the database table.
type Component struct {
	ID          string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	ExternalID  string      `boil:"external_id" json:"external_id" toml:"external_id" yaml:"external_id"`
	ParentID    null.String `boil:"parent_id" json:"parent_id,omitempty" toml:"parent_id" yaml:"parent_id,omitempty"`
	SystemID    null.String `boil:"system_id" json:"system_id,omitempty" toml:"system_id" yaml:"system_id,omitempty"`
	Name        string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Text        null.String `boil:"text" json:"text,omitempty" toml:"text" yaml:"text,omitempty"`
	Labels      null.JSON   `boil:"labels" json:"labels,omitempty" toml:"labels" yaml:"labels,omitempty"`
	Hidden      bool        `boil:"hidden" json:"hidden" toml:"hidden" yaml:"hidden"`
	Silenced    bool        `boil:"silenced" json:"silenced" toml:"silenced" yaml:"silenced"`
	Status      string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	Description null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	Lifecycle   null.String `boil:"lifecycle" json:"lifecycle,omitempty" toml:"lifecycle" yaml:"lifecycle,omitempty"`
	Tooltip     null.String `boil:"tooltip" json:"tooltip,omitempty" toml:"tooltip" yaml:"tooltip,omitempty"`
	Icon        null.String `boil:"icon" json:"icon,omitempty" toml:"icon" yaml:"icon,omitempty"`
	Type        null.String `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	Owner       null.String `boil:"owner" json:"owner,omitempty" toml:"owner" yaml:"owner,omitempty"`
	Spec        null.JSON   `boil:"spec" json:"spec,omitempty" toml:"spec" yaml:"spec,omitempty"`
	Properties  null.JSON   `boil:"properties" json:"properties,omitempty" toml:"properties" yaml:"properties,omitempty"`
	CreatedAt   time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt   time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *componentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L componentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ComponentColumns = struct {
	ID          string
	ExternalID  string
	ParentID    string
	SystemID    string
	Name        string
	Text        string
	Labels      string
	Hidden      string
	Silenced    string
	Status      string
	Description string
	Lifecycle   string
	Tooltip     string
	Icon        string
	Type        string
	Owner       string
	Spec        string
	Properties  string
	CreatedAt   string
	UpdatedAt   string
}{
	ID:          "id",
	ExternalID:  "external_id",
	ParentID:    "parent_id",
	SystemID:    "system_id",
	Name:        "name",
	Text:        "text",
	Labels:      "labels",
	Hidden:      "hidden",
	Silenced:    "silenced",
	Status:      "status",
	Description: "description",
	Lifecycle:   "lifecycle",
	Tooltip:     "tooltip",
	Icon:        "icon",
	Type:        "type",
	Owner:       "owner",
	Spec:        "spec",
	Properties:  "properties",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
}

var ComponentTableColumns = struct {
	ID          string
	ExternalID  string
	ParentID    string
	SystemID    string
	Name        string
	Text        string
	Labels      string
	Hidden      string
	Silenced    string
	Status      string
	Description string
	Lifecycle   string
	Tooltip     string
	Icon        string
	Type        string
	Owner       string
	Spec        string
	Properties  string
	CreatedAt   string
	UpdatedAt   string
}{
	ID:          "component.id",
	ExternalID:  "component.external_id",
	ParentID:    "component.parent_id",
	SystemID:    "component.system_id",
	Name:        "component.name",
	Text:        "component.text",
	Labels:      "component.labels",
	Hidden:      "component.hidden",
	Silenced:    "component.silenced",
	Status:      "component.status",
	Description: "component.description",
	Lifecycle:   "component.lifecycle",
	Tooltip:     "component.tooltip",
	Icon:        "component.icon",
	Type:        "component.type",
	Owner:       "component.owner",
	Spec:        "component.spec",
	Properties:  "component.properties",
	CreatedAt:   "component.created_at",
	UpdatedAt:   "component.updated_at",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var ComponentWhere = struct {
	ID          whereHelperstring
	ExternalID  whereHelperstring
	ParentID    whereHelpernull_String
	SystemID    whereHelpernull_String
	Name        whereHelperstring
	Text        whereHelpernull_String
	Labels      whereHelpernull_JSON
	Hidden      whereHelperbool
	Silenced    whereHelperbool
	Status      whereHelperstring
	Description whereHelpernull_String
	Lifecycle   whereHelpernull_String
	Tooltip     whereHelpernull_String
	Icon        whereHelpernull_String
	Type        whereHelpernull_String
	Owner       whereHelpernull_String
	Spec        whereHelpernull_JSON
	Properties  whereHelpernull_JSON
	CreatedAt   whereHelpertime_Time
	UpdatedAt   whereHelpertime_Time
}{
	ID:          whereHelperstring{field: "\"component\".\"id\""},
	ExternalID:  whereHelperstring{field: "\"component\".\"external_id\""},
	ParentID:    whereHelpernull_String{field: "\"component\".\"parent_id\""},
	SystemID:    whereHelpernull_String{field: "\"component\".\"system_id\""},
	Name:        whereHelperstring{field: "\"component\".\"name\""},
	Text:        whereHelpernull_String{field: "\"component\".\"text\""},
	Labels:      whereHelpernull_JSON{field: "\"component\".\"labels\""},
	Hidden:      whereHelperbool{field: "\"component\".\"hidden\""},
	Silenced:    whereHelperbool{field: "\"component\".\"silenced\""},
	Status:      whereHelperstring{field: "\"component\".\"status\""},
	Description: whereHelpernull_String{field: "\"component\".\"description\""},
	Lifecycle:   whereHelpernull_String{field: "\"component\".\"lifecycle\""},
	Tooltip:     whereHelpernull_String{field: "\"component\".\"tooltip\""},
	Icon:        whereHelpernull_String{field: "\"component\".\"icon\""},
	Type:        whereHelpernull_String{field: "\"component\".\"type\""},
	Owner:       whereHelpernull_String{field: "\"component\".\"owner\""},
	Spec:        whereHelpernull_JSON{field: "\"component\".\"spec\""},
	Properties:  whereHelpernull_JSON{field: "\"component\".\"properties\""},
	CreatedAt:   whereHelpertime_Time{field: "\"component\".\"created_at\""},
	UpdatedAt:   whereHelpertime_Time{field: "\"component\".\"updated_at\""},
}

// ComponentRels is where relationship names are stored.
var ComponentRels = struct {
	Parent           string
	System           string
	ParentComponents string
}{
	Parent:           "Parent",
	System:           "System",
	ParentComponents: "ParentComponents",
}

// componentR is where relationships are stored.
type componentR struct {
	Parent           *Component     `boil:"Parent" json:"Parent" toml:"Parent" yaml:"Parent"`
	System           *System        `boil:"System" json:"System" toml:"System" yaml:"System"`
	ParentComponents ComponentSlice `boil:"ParentComponents" json:"ParentComponents" toml:"ParentComponents" yaml:"ParentComponents"`
}

// NewStruct creates a new relationship struct
func (*componentR) NewStruct() *componentR {
	return &componentR{}
}

// componentL is where Load methods for each relationship are stored.
type componentL struct{}

var (
	componentAllColumns            = []string{"id", "external_id", "parent_id", "system_id", "name", "text", "labels", "hidden", "silenced", "status", "description", "lifecycle", "tooltip", "icon", "type", "owner", "spec", "properties", "created_at", "updated_at"}
	componentColumnsWithoutDefault = []string{"external_id", "parent_id", "system_id", "name", "text", "labels", "status", "description", "lifecycle", "tooltip", "icon", "type", "owner", "spec", "properties"}
	componentColumnsWithDefault    = []string{"id", "hidden", "silenced", "created_at", "updated_at"}
	componentPrimaryKeyColumns     = []string{"id"}
)

type (
	// ComponentSlice is an alias for a slice of pointers to Component.
	// This should almost always be used instead of []Component.
	ComponentSlice []*Component
	// ComponentHook is the signature for custom Component hook methods
	ComponentHook func(boil.Executor, *Component) error

	componentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	componentType                 = reflect.TypeOf(&Component{})
	componentMapping              = queries.MakeStructMapping(componentType)
	componentPrimaryKeyMapping, _ = queries.BindMapping(componentType, componentMapping, componentPrimaryKeyColumns)
	componentInsertCacheMut       sync.RWMutex
	componentInsertCache          = make(map[string]insertCache)
	componentUpdateCacheMut       sync.RWMutex
	componentUpdateCache          = make(map[string]updateCache)
	componentUpsertCacheMut       sync.RWMutex
	componentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var componentBeforeInsertHooks []ComponentHook
var componentBeforeUpdateHooks []ComponentHook
var componentBeforeDeleteHooks []ComponentHook
var componentBeforeUpsertHooks []ComponentHook

var componentAfterInsertHooks []ComponentHook
var componentAfterSelectHooks []ComponentHook
var componentAfterUpdateHooks []ComponentHook
var componentAfterDeleteHooks []ComponentHook
var componentAfterUpsertHooks []ComponentHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Component) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range componentBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Component) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range componentBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Component) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range componentBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Component) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range componentBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Component) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range componentAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Component) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range componentAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Component) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range componentAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Component) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range componentAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Component) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range componentAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddComponentHook registers your hook function for all future operations.
func AddComponentHook(hookPoint boil.HookPoint, componentHook ComponentHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		componentBeforeInsertHooks = append(componentBeforeInsertHooks, componentHook)
	case boil.BeforeUpdateHook:
		componentBeforeUpdateHooks = append(componentBeforeUpdateHooks, componentHook)
	case boil.BeforeDeleteHook:
		componentBeforeDeleteHooks = append(componentBeforeDeleteHooks, componentHook)
	case boil.BeforeUpsertHook:
		componentBeforeUpsertHooks = append(componentBeforeUpsertHooks, componentHook)
	case boil.AfterInsertHook:
		componentAfterInsertHooks = append(componentAfterInsertHooks, componentHook)
	case boil.AfterSelectHook:
		componentAfterSelectHooks = append(componentAfterSelectHooks, componentHook)
	case boil.AfterUpdateHook:
		componentAfterUpdateHooks = append(componentAfterUpdateHooks, componentHook)
	case boil.AfterDeleteHook:
		componentAfterDeleteHooks = append(componentAfterDeleteHooks, componentHook)
	case boil.AfterUpsertHook:
		componentAfterUpsertHooks = append(componentAfterUpsertHooks, componentHook)
	}
}

// OneG returns a single component record from the query using the global executor.
func (q componentQuery) OneG() (*Component, error) {
	return q.One(boil.GetDB())
}

// One returns a single component record from the query.
func (q componentQuery) One(exec boil.Executor) (*Component, error) {
	o := &Component{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for component")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Component records from the query using the global executor.
func (q componentQuery) AllG() (ComponentSlice, error) {
	return q.All(boil.GetDB())
}

// All returns all Component records from the query.
func (q componentQuery) All(exec boil.Executor) (ComponentSlice, error) {
	var o []*Component

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Component slice")
	}

	if len(componentAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Component records in the query, and panics on error.
func (q componentQuery) CountG() (int64, error) {
	return q.Count(boil.GetDB())
}

// Count returns the count of all Component records in the query.
func (q componentQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count component rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q componentQuery) ExistsG() (bool, error) {
	return q.Exists(boil.GetDB())
}

// Exists checks if the row exists in the table.
func (q componentQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if component exists")
	}

	return count > 0, nil
}

// Parent pointed to by the foreign key.
func (o *Component) Parent(mods ...qm.QueryMod) componentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ParentID),
	}

	queryMods = append(queryMods, mods...)

	query := Components(queryMods...)
	queries.SetFrom(query.Query, "\"component\"")

	return query
}

// System pointed to by the foreign key.
func (o *Component) System(mods ...qm.QueryMod) systemQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SystemID),
	}

	queryMods = append(queryMods, mods...)

	query := Systems(queryMods...)
	queries.SetFrom(query.Query, "\"system\"")

	return query
}

// ParentComponents retrieves all the component's Components with an executor via parent_id column.
func (o *Component) ParentComponents(mods ...qm.QueryMod) componentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"component\".\"parent_id\"=?", o.ID),
	)

	query := Components(queryMods...)
	queries.SetFrom(query.Query, "\"component\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"component\".*"})
	}

	return query
}

// LoadParent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (componentL) LoadParent(e boil.Executor, singular bool, maybeComponent interface{}, mods queries.Applicator) error {
	var slice []*Component
	var object *Component

	if singular {
		object = maybeComponent.(*Component)
	} else {
		slice = *maybeComponent.(*[]*Component)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &componentR{}
		}
		if !queries.IsNil(object.ParentID) {
			args = append(args, object.ParentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &componentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ParentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ParentID) {
				args = append(args, obj.ParentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`component`),
		qm.WhereIn(`component.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Component")
	}

	var resultSlice []*Component
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Component")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for component")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for component")
	}

	if len(componentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Parent = foreign
		if foreign.R == nil {
			foreign.R = &componentR{}
		}
		foreign.R.ParentComponents = append(foreign.R.ParentComponents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ParentID, foreign.ID) {
				local.R.Parent = foreign
				if foreign.R == nil {
					foreign.R = &componentR{}
				}
				foreign.R.ParentComponents = append(foreign.R.ParentComponents, local)
				break
			}
		}
	}

	return nil
}

// LoadSystem allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (componentL) LoadSystem(e boil.Executor, singular bool, maybeComponent interface{}, mods queries.Applicator) error {
	var slice []*Component
	var object *Component

	if singular {
		object = maybeComponent.(*Component)
	} else {
		slice = *maybeComponent.(*[]*Component)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &componentR{}
		}
		if !queries.IsNil(object.SystemID) {
			args = append(args, object.SystemID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &componentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SystemID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SystemID) {
				args = append(args, obj.SystemID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`system`),
		qm.WhereIn(`system.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load System")
	}

	var resultSlice []*System
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice System")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for system")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for system")
	}

	if len(componentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.System = foreign
		if foreign.R == nil {
			foreign.R = &systemR{}
		}
		foreign.R.Components = append(foreign.R.Components, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SystemID, foreign.ID) {
				local.R.System = foreign
				if foreign.R == nil {
					foreign.R = &systemR{}
				}
				foreign.R.Components = append(foreign.R.Components, local)
				break
			}
		}
	}

	return nil
}

// LoadParentComponents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (componentL) LoadParentComponents(e boil.Executor, singular bool, maybeComponent interface{}, mods queries.Applicator) error {
	var slice []*Component
	var object *Component

	if singular {
		object = maybeComponent.(*Component)
	} else {
		slice = *maybeComponent.(*[]*Component)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &componentR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &componentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`component`),
		qm.WhereIn(`component.parent_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load component")
	}

	var resultSlice []*Component
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice component")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on component")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for component")
	}

	if len(componentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ParentComponents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &componentR{}
			}
			foreign.R.Parent = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ParentID) {
				local.R.ParentComponents = append(local.R.ParentComponents, foreign)
				if foreign.R == nil {
					foreign.R = &componentR{}
				}
				foreign.R.Parent = local
				break
			}
		}
	}

	return nil
}

// SetParentG of the component to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComponents.
// Uses the global database handle.
func (o *Component) SetParentG(insert bool, related *Component) error {
	return o.SetParent(boil.GetDB(), insert, related)
}

// SetParent of the component to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComponents.
func (o *Component) SetParent(exec boil.Executor, insert bool, related *Component) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"component\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"parent_id"}),
		strmangle.WhereClause("\"", "\"", 2, componentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ParentID, related.ID)
	if o.R == nil {
		o.R = &componentR{
			Parent: related,
		}
	} else {
		o.R.Parent = related
	}

	if related.R == nil {
		related.R = &componentR{
			ParentComponents: ComponentSlice{o},
		}
	} else {
		related.R.ParentComponents = append(related.R.ParentComponents, o)
	}

	return nil
}

// RemoveParentG relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Component) RemoveParentG(related *Component) error {
	return o.RemoveParent(boil.GetDB(), related)
}

// RemoveParent relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Component) RemoveParent(exec boil.Executor, related *Component) error {
	var err error

	queries.SetScanner(&o.ParentID, nil)
	if _, err = o.Update(exec, boil.Whitelist("parent_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Parent = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ParentComponents {
		if queries.Equal(o.ParentID, ri.ParentID) {
			continue
		}

		ln := len(related.R.ParentComponents)
		if ln > 1 && i < ln-1 {
			related.R.ParentComponents[i] = related.R.ParentComponents[ln-1]
		}
		related.R.ParentComponents = related.R.ParentComponents[:ln-1]
		break
	}
	return nil
}

// SetSystemG of the component to the related item.
// Sets o.R.System to related.
// Adds o to related.R.Components.
// Uses the global database handle.
func (o *Component) SetSystemG(insert bool, related *System) error {
	return o.SetSystem(boil.GetDB(), insert, related)
}

// SetSystem of the component to the related item.
// Sets o.R.System to related.
// Adds o to related.R.Components.
func (o *Component) SetSystem(exec boil.Executor, insert bool, related *System) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"component\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"system_id"}),
		strmangle.WhereClause("\"", "\"", 2, componentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SystemID, related.ID)
	if o.R == nil {
		o.R = &componentR{
			System: related,
		}
	} else {
		o.R.System = related
	}

	if related.R == nil {
		related.R = &systemR{
			Components: ComponentSlice{o},
		}
	} else {
		related.R.Components = append(related.R.Components, o)
	}

	return nil
}

// RemoveSystemG relationship.
// Sets o.R.System to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Component) RemoveSystemG(related *System) error {
	return o.RemoveSystem(boil.GetDB(), related)
}

// RemoveSystem relationship.
// Sets o.R.System to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Component) RemoveSystem(exec boil.Executor, related *System) error {
	var err error

	queries.SetScanner(&o.SystemID, nil)
	if _, err = o.Update(exec, boil.Whitelist("system_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.System = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Components {
		if queries.Equal(o.SystemID, ri.SystemID) {
			continue
		}

		ln := len(related.R.Components)
		if ln > 1 && i < ln-1 {
			related.R.Components[i] = related.R.Components[ln-1]
		}
		related.R.Components = related.R.Components[:ln-1]
		break
	}
	return nil
}

// AddParentComponentsG adds the given related objects to the existing relationships
// of the component, optionally inserting them as new records.
// Appends related to o.R.ParentComponents.
// Sets related.R.Parent appropriately.
// Uses the global database handle.
func (o *Component) AddParentComponentsG(insert bool, related ...*Component) error {
	return o.AddParentComponents(boil.GetDB(), insert, related...)
}

// AddParentComponents adds the given related objects to the existing relationships
// of the component, optionally inserting them as new records.
// Appends related to o.R.ParentComponents.
// Sets related.R.Parent appropriately.
func (o *Component) AddParentComponents(exec boil.Executor, insert bool, related ...*Component) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"component\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"parent_id"}),
				strmangle.WhereClause("\"", "\"", 2, componentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &componentR{
			ParentComponents: related,
		}
	} else {
		o.R.ParentComponents = append(o.R.ParentComponents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &componentR{
				Parent: o,
			}
		} else {
			rel.R.Parent = o
		}
	}
	return nil
}

// SetParentComponentsG removes all previously related items of the
// component replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComponents accordingly.
// Replaces o.R.ParentComponents with related.
// Sets related.R.Parent's ParentComponents accordingly.
// Uses the global database handle.
func (o *Component) SetParentComponentsG(insert bool, related ...*Component) error {
	return o.SetParentComponents(boil.GetDB(), insert, related...)
}

// SetParentComponents removes all previously related items of the
// component replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComponents accordingly.
// Replaces o.R.ParentComponents with related.
// Sets related.R.Parent's ParentComponents accordingly.
func (o *Component) SetParentComponents(exec boil.Executor, insert bool, related ...*Component) error {
	query := "update \"component\" set \"parent_id\" = null where \"parent_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentComponents {
			queries.SetScanner(&rel.ParentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Parent = nil
		}

		o.R.ParentComponents = nil
	}
	return o.AddParentComponents(exec, insert, related...)
}

// RemoveParentComponentsG relationships from objects passed in.
// Removes related items from R.ParentComponents (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
// Uses the global database handle.
func (o *Component) RemoveParentComponentsG(related ...*Component) error {
	return o.RemoveParentComponents(boil.GetDB(), related...)
}

// RemoveParentComponents relationships from objects passed in.
// Removes related items from R.ParentComponents (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
func (o *Component) RemoveParentComponents(exec boil.Executor, related ...*Component) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentID, nil)
		if rel.R != nil {
			rel.R.Parent = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("parent_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentComponents {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentComponents)
			if ln > 1 && i < ln-1 {
				o.R.ParentComponents[i] = o.R.ParentComponents[ln-1]
			}
			o.R.ParentComponents = o.R.ParentComponents[:ln-1]
			break
		}
	}

	return nil
}

// Components retrieves all the records using an executor.
func Components(mods ...qm.QueryMod) componentQuery {
	mods = append(mods, qm.From("\"component\""))
	return componentQuery{NewQuery(mods...)}
}

// FindComponentG retrieves a single record by ID.
func FindComponentG(iD string, selectCols ...string) (*Component, error) {
	return FindComponent(boil.GetDB(), iD, selectCols...)
}

// FindComponent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindComponent(exec boil.Executor, iD string, selectCols ...string) (*Component, error) {
	componentObj := &Component{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"component\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, componentObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from component")
	}

	if err = componentObj.doAfterSelectHooks(exec); err != nil {
		return componentObj, err
	}

	return componentObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Component) InsertG(columns boil.Columns) error {
	return o.Insert(boil.GetDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Component) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no component provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(componentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	componentInsertCacheMut.RLock()
	cache, cached := componentInsertCache[key]
	componentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			componentAllColumns,
			componentColumnsWithDefault,
			componentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(componentType, componentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(componentType, componentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"component\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"component\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into component")
	}

	if !cached {
		componentInsertCacheMut.Lock()
		componentInsertCache[key] = cache
		componentInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// UpdateG a single Component record using the global executor.
// See Update for more documentation.
func (o *Component) UpdateG(columns boil.Columns) (int64, error) {
	return o.Update(boil.GetDB(), columns)
}

// Update uses an executor to update the Component.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Component) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	componentUpdateCacheMut.RLock()
	cache, cached := componentUpdateCache[key]
	componentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			componentAllColumns,
			componentPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update component, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"component\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, componentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(componentType, componentMapping, append(wl, componentPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update component row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for component")
	}

	if !cached {
		componentUpdateCacheMut.Lock()
		componentUpdateCache[key] = cache
		componentUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q componentQuery) UpdateAllG(cols M) (int64, error) {
	return q.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q componentQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for component")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for component")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ComponentSlice) UpdateAllG(cols M) (int64, error) {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ComponentSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), componentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"component\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, componentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in component slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all component")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Component) UpsertG(updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(boil.GetDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Component) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no component provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(componentColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	componentUpsertCacheMut.RLock()
	cache, cached := componentUpsertCache[key]
	componentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			componentAllColumns,
			componentColumnsWithDefault,
			componentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			componentAllColumns,
			componentPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert component, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(componentPrimaryKeyColumns))
			copy(conflict, componentPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"component\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(componentType, componentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(componentType, componentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert component")
	}

	if !cached {
		componentUpsertCacheMut.Lock()
		componentUpsertCache[key] = cache
		componentUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// DeleteG deletes a single Component record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Component) DeleteG() (int64, error) {
	return o.Delete(boil.GetDB())
}

// Delete deletes a single Component record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Component) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Component provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), componentPrimaryKeyMapping)
	sql := "DELETE FROM \"component\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from component")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for component")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q componentQuery) DeleteAllG() (int64, error) {
	return q.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all matching rows.
func (q componentQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no componentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from component")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for component")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ComponentSlice) DeleteAllG() (int64, error) {
	return o.DeleteAll(boil.GetDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ComponentSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(componentBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), componentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"component\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, componentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from component slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for component")
	}

	if len(componentAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Component) ReloadG() error {
	if o == nil {
		return errors.New("models: no Component provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Component) Reload(exec boil.Executor) error {
	ret, err := FindComponent(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ComponentSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("models: empty ComponentSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ComponentSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ComponentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), componentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"component\".* FROM \"component\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, componentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ComponentSlice")
	}

	*o = slice

	return nil
}

// ComponentExistsG checks if the Component row exists.
func ComponentExistsG(iD string) (bool, error) {
	return ComponentExists(boil.GetDB(), iD)
}

// ComponentExists checks if the Component row exists.
func ComponentExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"component\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if component exists")
	}

	return exists, nil
}
